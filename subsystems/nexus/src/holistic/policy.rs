//! # Policy Engine
//!
//! Declarative policy rules that define when and how the system should
//! react to certain conditions. Policies are evaluated against the current
//! system snapshot and produce optimization actions.

use alloc::vec::Vec;

use super::global::SystemSnapshot;
use super::orchestrate::{ActionPriority, ActionSource, OptAction};

// ============================================================================
// POLICY CONDITIONS
// ============================================================================

/// A condition that triggers a policy rule
#[derive(Debug, Clone, Copy)]
pub enum PolicyCondition {
    /// CPU utilization exceeds threshold
    CpuAbove(f64),
    /// CPU utilization below threshold
    CpuBelow(f64),
    /// Memory pressure exceeds threshold
    MemoryPressureAbove(f64),
    /// I/O pressure exceeds threshold
    IoPressureAbove(f64),
    /// Overall system pressure exceeds threshold
    SystemPressureAbove(f64),
    /// Run queue length exceeds threshold
    RunQueueAbove(u32),
    /// Memory free below threshold (bytes)
    FreeMemoryBelow(u64),
    /// Page fault rate exceeds threshold
    PageFaultRateAbove(u64),
    /// Context switch rate exceeds threshold
    ContextSwitchRateAbove(u64),
    /// Always true
    Always,
}

impl PolicyCondition {
    /// Evaluate the condition against a snapshot
    pub fn evaluate(&self, snapshot: &SystemSnapshot) -> bool {
        match *self {
            Self::CpuAbove(t) => snapshot.cpu.utilization > t,
            Self::CpuBelow(t) => snapshot.cpu.utilization < t,
            Self::MemoryPressureAbove(t) => snapshot.memory.pressure > t,
            Self::IoPressureAbove(t) => snapshot.io.pressure > t,
            Self::SystemPressureAbove(t) => snapshot.overall_pressure() > t,
            Self::RunQueueAbove(t) => snapshot.cpu.run_queue_length > t,
            Self::FreeMemoryBelow(t) => snapshot.memory.free < t,
            Self::PageFaultRateAbove(t) => snapshot.memory.page_faults_per_sec > t,
            Self::ContextSwitchRateAbove(t) => snapshot.cpu.context_switches_per_sec > t,
            Self::Always => true,
        }
    }
}

// ============================================================================
// POLICY ACTIONS
// ============================================================================

/// An action template generated by a policy
#[derive(Debug, Clone, Copy)]
pub enum PolicyAction {
    /// Compact memory
    CompactMemory,
    /// Throttle low-priority processes
    ThrottleLowPriority,
    /// Boost interactive processes
    BoostInteractive,
    /// Enable power saving
    EnablePowerSaving,
    /// Disable power saving
    DisablePowerSaving,
    /// Global rebalance
    GlobalRebalance,
    /// Reduce scheduler quantum
    ReduceQuantum,
    /// Increase scheduler quantum
    IncreaseQuantum,
    /// Send memory pressure advisory to cooperative apps
    AdviseMemoryPressure,
    /// Send CPU contention advisory to cooperative apps
    AdviseCpuContention,
}

impl PolicyAction {
    /// Convert to a concrete optimization action
    pub fn to_opt_action(&self) -> OptAction {
        match self {
            Self::CompactMemory => OptAction::CompactMemory { urgency: 5 },
            Self::ThrottleLowPriority => OptAction::AdjustScheduler {
                quantum_us: 5000,
                preemption_threshold: 3,
            },
            Self::BoostInteractive => OptAction::AdjustScheduler {
                quantum_us: 1000,
                preemption_threshold: 1,
            },
            Self::EnablePowerSaving => OptAction::PowerSaving { level: 2 },
            Self::DisablePowerSaving => OptAction::PowerSaving { level: 0 },
            Self::GlobalRebalance => OptAction::GlobalRebalance,
            Self::ReduceQuantum => OptAction::AdjustScheduler {
                quantum_us: 2000,
                preemption_threshold: 2,
            },
            Self::IncreaseQuantum => OptAction::AdjustScheduler {
                quantum_us: 10000,
                preemption_threshold: 5,
            },
            Self::AdviseMemoryPressure => OptAction::CompactMemory { urgency: 3 },
            Self::AdviseCpuContention => OptAction::GlobalRebalance,
        }
    }
}

// ============================================================================
// POLICY RULES
// ============================================================================

/// A policy rule: condition â†’ action
#[derive(Debug, Clone)]
pub struct PolicyRule {
    /// Condition to check
    pub condition: PolicyCondition,
    /// Action to take if condition is true
    pub action: PolicyAction,
    /// Priority of the generated action
    pub priority: u8,
    /// Whether this rule is enabled
    pub enabled: bool,
    /// Minimum interval between triggers (ms)
    pub cooldown_ms: u64,
    /// Last time this rule was triggered
    last_triggered: u64,
    /// Times this rule has fired
    pub fire_count: u64,
}

impl PolicyRule {
    pub fn new(condition: PolicyCondition, action: PolicyAction, priority: u8) -> Self {
        Self {
            condition,
            action,
            priority,
            enabled: true,
            cooldown_ms: 1000,
            last_triggered: 0,
            fire_count: 0,
        }
    }

    pub fn with_cooldown(mut self, ms: u64) -> Self {
        self.cooldown_ms = ms;
        self
    }

    /// Check if the rule should fire
    pub fn should_fire(&self, snapshot: &SystemSnapshot, current_time: u64) -> bool {
        self.enabled
            && current_time.saturating_sub(self.last_triggered) >= self.cooldown_ms
            && self.condition.evaluate(snapshot)
    }

    /// Fire the rule and return the action
    pub fn fire(&mut self, current_time: u64) -> OptAction {
        self.last_triggered = current_time;
        self.fire_count += 1;
        self.action.to_opt_action()
    }
}

// ============================================================================
// POLICY ENGINE
// ============================================================================

/// The policy engine evaluates rules against system state
pub struct PolicyEngine {
    /// Registered rules
    rules: Vec<PolicyRule>,
    /// Total evaluations
    evaluations: u64,
    /// Total actions generated
    actions_generated: u64,
}

impl PolicyEngine {
    pub fn new() -> Self {
        Self {
            rules: Vec::new(),
            evaluations: 0,
            actions_generated: 0,
        }
    }

    /// Create with default rules
    pub fn with_defaults() -> Self {
        let mut engine = Self::new();

        // Memory pressure rules
        engine.add_rule(
            PolicyRule::new(
                PolicyCondition::MemoryPressureAbove(0.8),
                PolicyAction::CompactMemory,
                2,
            )
            .with_cooldown(5000),
        );
        engine.add_rule(
            PolicyRule::new(
                PolicyCondition::MemoryPressureAbove(0.9),
                PolicyAction::AdviseMemoryPressure,
                1,
            )
            .with_cooldown(2000),
        );

        // CPU rules
        engine.add_rule(
            PolicyRule::new(
                PolicyCondition::CpuAbove(0.9),
                PolicyAction::ThrottleLowPriority,
                2,
            )
            .with_cooldown(3000),
        );
        engine.add_rule(
            PolicyRule::new(
                PolicyCondition::CpuBelow(0.2),
                PolicyAction::EnablePowerSaving,
                4,
            )
            .with_cooldown(10000),
        );
        engine.add_rule(
            PolicyRule::new(
                PolicyCondition::CpuAbove(0.5),
                PolicyAction::DisablePowerSaving,
                3,
            )
            .with_cooldown(5000),
        );

        // System pressure rules
        engine.add_rule(
            PolicyRule::new(
                PolicyCondition::SystemPressureAbove(0.85),
                PolicyAction::GlobalRebalance,
                1,
            )
            .with_cooldown(5000),
        );

        // Run queue rules
        engine.add_rule(
            PolicyRule::new(
                PolicyCondition::RunQueueAbove(100),
                PolicyAction::ReduceQuantum,
                2,
            )
            .with_cooldown(5000),
        );

        engine
    }

    /// Add a policy rule
    pub fn add_rule(&mut self, rule: PolicyRule) {
        self.rules.push(rule);
    }

    /// Evaluate all rules against the current snapshot
    pub fn evaluate(
        &mut self,
        snapshot: &SystemSnapshot,
        current_time: u64,
    ) -> Vec<(OptAction, ActionPriority, ActionSource)> {
        self.evaluations += 1;
        let mut actions = Vec::new();

        for rule in &mut self.rules {
            if rule.should_fire(snapshot, current_time) {
                let action = rule.fire(current_time);
                let priority = ActionPriority(rule.priority);
                actions.push((action, priority, ActionSource::Policy));
                self.actions_generated += 1;
            }
        }

        actions
    }

    /// Number of registered rules
    pub fn rule_count(&self) -> usize {
        self.rules.len()
    }

    /// Get evaluation statistics
    pub fn stats(&self) -> (u64, u64) {
        (self.evaluations, self.actions_generated)
    }
}

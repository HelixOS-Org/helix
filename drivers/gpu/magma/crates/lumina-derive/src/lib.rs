//! # Lumina Derive
//!
//! Procedural macros for the Lumina graphics API.
//!
//! This crate provides the following derive macros:
//! - `GpuData` - For types that can be stored in GPU buffers
//! - `GpuVertex` - For vertex buffer layouts
//! - `GpuUniforms` - For uniform buffer layouts
//!
//! And the following attribute macros:
//! - `#[lumina::shader(vertex)]` - Compile Rust to vertex shader
//! - `#[lumina::shader(fragment)]` - Compile Rust to fragment shader
//! - `#[lumina::shader(compute)]` - Compile Rust to compute shader

use proc_macro::TokenStream;
use quote::quote;
use syn::{parse_macro_input, DeriveInput, ItemFn};

/// Derive macro for `GpuData` trait
///
/// Makes a type safe for GPU buffer storage.
///
/// # Example
///
/// ```rust
/// #[derive(Clone, Copy, GpuData)]
/// struct Particle {
///     position: Vec3,
///     velocity: Vec3,
///     lifetime: f32,
/// }
/// ```
#[proc_macro_derive(GpuData)]
pub fn derive_gpu_data(input: TokenStream) -> TokenStream {
    let input = parse_macro_input!(input as DeriveInput);
    let name = &input.ident;
    let (impl_generics, ty_generics, where_clause) = input.generics.split_for_impl();

    let expanded = quote! {
        // Safety: This is generated by the derive macro which ensures
        // the type is Copy and has a well-defined layout
        unsafe impl #impl_generics lumina::types::GpuData for #name #ty_generics #where_clause {}
    };

    TokenStream::from(expanded)
}

/// Derive macro for `GpuVertex` trait
///
/// Generates vertex attribute descriptions for pipeline creation.
///
/// # Example
///
/// ```rust
/// #[derive(Clone, Copy, GpuVertex)]
/// struct Vertex {
///     #[location(0)]
///     position: Vec3,
///     #[location(1)]
///     normal: Vec3,
///     #[location(2)]
///     uv: Vec2,
/// }
/// ```
#[proc_macro_derive(GpuVertex, attributes(location))]
pub fn derive_gpu_vertex(input: TokenStream) -> TokenStream {
    let input = parse_macro_input!(input as DeriveInput);
    let name = &input.ident;
    let (impl_generics, ty_generics, where_clause) = input.generics.split_for_impl();

    // Extract fields and their locations
    let fields = match &input.data {
        syn::Data::Struct(data) => match &data.fields {
            syn::Fields::Named(fields) => &fields.named,
            _ => panic!("GpuVertex only supports structs with named fields"),
        },
        _ => panic!("GpuVertex only supports structs"),
    };

    let mut attributes = Vec::new();
    let mut offset = 0u32;
    let mut location = 0u32;

    for field in fields {
        let field_name = field.ident.as_ref().unwrap();
        let field_type = &field.ty;

        // Check for #[location(N)] attribute
        for attr in &field.attrs {
            if attr.path().is_ident("location") {
                let loc: syn::LitInt = attr.parse_args().unwrap();
                location = loc.base10_parse().unwrap();
            }
        }

        // Determine format from type
        let (format, size) = type_to_format_and_size(field_type);

        attributes.push(quote! {
            lumina::types::VertexAttribute {
                location: #location,
                offset: #offset,
                format: #format,
            }
        });

        offset += size;
        location += 1;
    }

    let attr_count = attributes.len();

    let expanded = quote! {
        // Safety: Generated by derive macro
        unsafe impl #impl_generics lumina::types::GpuData for #name #ty_generics #where_clause {}

        impl #impl_generics lumina::types::GpuVertex for #name #ty_generics #where_clause {
            fn attributes() -> &'static [lumina::types::VertexAttribute] {
                static ATTRS: [lumina::types::VertexAttribute; #attr_count] = [
                    #(#attributes),*
                ];
                &ATTRS
            }
        }
    };

    TokenStream::from(expanded)
}

/// Derive macro for `GpuUniforms` trait
///
/// Generates uniform buffer layout information.
///
/// # Example
///
/// ```rust
/// #[derive(Clone, Copy, GpuUniforms)]
/// struct SceneUniforms {
///     model: Mat4,
///     view: Mat4,
///     projection: Mat4,
///     time: f32,
/// }
/// ```
#[proc_macro_derive(GpuUniforms)]
pub fn derive_gpu_uniforms(input: TokenStream) -> TokenStream {
    let input = parse_macro_input!(input as DeriveInput);
    let name = &input.ident;
    let (impl_generics, ty_generics, where_clause) = input.generics.split_for_impl();

    // Extract fields
    let fields = match &input.data {
        syn::Data::Struct(data) => match &data.fields {
            syn::Fields::Named(fields) => &fields.named,
            _ => panic!("GpuUniforms only supports structs with named fields"),
        },
        _ => panic!("GpuUniforms only supports structs"),
    };

    let mut members = Vec::new();
    let mut offset = 0u32;

    for field in fields {
        let field_name = field.ident.as_ref().unwrap();
        let field_name_str = field_name.to_string();
        let field_type = &field.ty;

        let (uniform_type, size, alignment) = type_to_uniform_info(field_type);

        // Align offset
        offset = (offset + alignment - 1) & !(alignment - 1);

        members.push(quote! {
            lumina::types::UniformMember {
                name: #field_name_str,
                offset: #offset,
                size: #size,
                ty: #uniform_type,
            }
        });

        offset += size;
    }

    let member_count = members.len();

    let expanded = quote! {
        // Safety: Generated by derive macro
        unsafe impl #impl_generics lumina::types::GpuData for #name #ty_generics #where_clause {}

        impl #impl_generics lumina::types::GpuUniforms for #name #ty_generics #where_clause {
            fn layout() -> &'static [lumina::types::UniformMember] {
                static LAYOUT: [lumina::types::UniformMember; #member_count] = [
                    #(#members),*
                ];
                &LAYOUT
            }
        }
    };

    TokenStream::from(expanded)
}

/// Attribute macro for shader functions
///
/// Transforms a Rust function into a GPU shader.
///
/// # Example
///
/// ```rust
/// #[lumina::shader(vertex)]
/// fn vertex_main(pos: Vec3, color: Vec3) -> VertexOutput<Vec3> {
///     VertexOutput {
///         position: pos.extend(1.0),
///         varying: color,
///     }
/// }
/// ```
#[proc_macro_attribute]
pub fn shader(attr: TokenStream, item: TokenStream) -> TokenStream {
    let _attr = attr.to_string();
    let input = parse_macro_input!(item as ItemFn);
    let name = &input.sig.ident;
    let vis = &input.vis;

    // For now, just generate a marker struct
    // Full implementation would use rust-gpu or similar
    let expanded = quote! {
        #vis struct #name;

        impl #name {
            pub const fn spirv() -> &'static [u32] {
                // Placeholder - would contain actual SPIR-V
                &[]
            }
        }
    };

    TokenStream::from(expanded)
}

/// Helper to convert a Rust type to AttributeFormat and size
fn type_to_format_and_size(ty: &syn::Type) -> (proc_macro2::TokenStream, u32) {
    let type_str = quote!(#ty).to_string().replace(' ', "");

    match type_str.as_str() {
        "f32" => (
            quote!(lumina::types::AttributeFormat::Float),
            4,
        ),
        "Vec2" | "lumina::math::Vec2" => (
            quote!(lumina::types::AttributeFormat::Vec2),
            8,
        ),
        "Vec3" | "lumina::math::Vec3" => (
            quote!(lumina::types::AttributeFormat::Vec3),
            12,
        ),
        "Vec4" | "lumina::math::Vec4" => (
            quote!(lumina::types::AttributeFormat::Vec4),
            16,
        ),
        "i32" => (
            quote!(lumina::types::AttributeFormat::Int),
            4,
        ),
        "u32" => (
            quote!(lumina::types::AttributeFormat::UInt),
            4,
        ),
        "[f32;2]" => (
            quote!(lumina::types::AttributeFormat::Vec2),
            8,
        ),
        "[f32;3]" => (
            quote!(lumina::types::AttributeFormat::Vec3),
            12,
        ),
        "[f32;4]" => (
            quote!(lumina::types::AttributeFormat::Vec4),
            16,
        ),
        _ => (
            quote!(lumina::types::AttributeFormat::Vec4),
            16,
        ),
    }
}

/// Helper to convert a Rust type to UniformType, size, and alignment
fn type_to_uniform_info(ty: &syn::Type) -> (proc_macro2::TokenStream, u32, u32) {
    let type_str = quote!(#ty).to_string().replace(' ', "");

    match type_str.as_str() {
        "f32" => (quote!(lumina::types::UniformType::Float), 4, 4),
        "Vec2" | "lumina::math::Vec2" => {
            (quote!(lumina::types::UniformType::Vec2), 8, 8)
        }
        "Vec3" | "lumina::math::Vec3" => {
            (quote!(lumina::types::UniformType::Vec3), 12, 16)
        }
        "Vec4" | "lumina::math::Vec4" => {
            (quote!(lumina::types::UniformType::Vec4), 16, 16)
        }
        "i32" => (quote!(lumina::types::UniformType::Int), 4, 4),
        "u32" => (quote!(lumina::types::UniformType::UInt), 4, 4),
        "Mat2" | "lumina::math::Mat2" => {
            (quote!(lumina::types::UniformType::Mat2), 16, 8)
        }
        "Mat3" | "lumina::math::Mat3" => {
            (quote!(lumina::types::UniformType::Mat3), 48, 16)
        }
        "Mat4" | "lumina::math::Mat4" => {
            (quote!(lumina::types::UniformType::Mat4), 64, 16)
        }
        _ => (quote!(lumina::types::UniformType::Vec4), 16, 16),
    }
}

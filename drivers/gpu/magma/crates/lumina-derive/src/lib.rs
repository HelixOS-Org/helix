//! # Lumina Derive
//!
//! Procedural macros for the Lumina graphics API.
//!
//! This crate provides the following derive macros:
//! - `GpuData` - For types that can be stored in GPU buffers
//! - `GpuVertex` - For vertex buffer layouts
//! - `GpuUniforms` - For uniform buffer layouts
//! - `GpuPushConstants` - For push constant layouts
//! - `GpuStorage` - For storage buffer layouts
//!
//! And the following attribute macros:
//! - `#[lumina::shader(vertex)]` - Compile Rust to vertex shader
//! - `#[lumina::shader(fragment)]` - Compile Rust to fragment shader
//! - `#[lumina::shader(compute)]` - Compile Rust to compute shader
//!
//! ## Layout Validation
//!
//! All derive macros validate:
//! - std140/std430 layout compliance
//! - Proper alignment of fields
//! - Padding requirements
//! - Nested struct support

use proc_macro::TokenStream;
use quote::quote;
use syn::{parse_macro_input, DeriveInput, ItemFn, Data, Fields, Attribute};

/// Derive macro for `GpuData` trait
///
/// Makes a type safe for GPU buffer storage.
/// Validates that the type has a well-defined memory layout.
///
/// # Attributes
///
/// - `#[repr(C)]` - Required for predictable layout
/// - `#[gpu(align = N)]` - Override alignment
/// - `#[gpu(packed)]` - Disable padding
///
/// # Example
///
/// ```rust
/// #[repr(C)]
/// #[derive(Clone, Copy, GpuData)]
/// struct Particle {
///     position: Vec3,
///     velocity: Vec3,
///     lifetime: f32,
///     _padding: f32, // Explicit padding
/// }
/// ```
#[proc_macro_derive(GpuData, attributes(gpu))]
pub fn derive_gpu_data(input: TokenStream) -> TokenStream {
    let input = parse_macro_input!(input as DeriveInput);
    let name = &input.ident;
    let (impl_generics, ty_generics, where_clause) = input.generics.split_for_impl();

    // Check for repr(C) attribute
    let has_repr_c = input.attrs.iter().any(|attr| {
        if attr.path().is_ident("repr") {
            if let Ok(repr) = attr.parse_args::<syn::Ident>() {
                return repr == "C";
            }
        }
        false
    });

    // Parse gpu attributes for custom alignment
    let custom_align = parse_gpu_align(&input.attrs);

    let validation = if has_repr_c {
        quote! {}
    } else {
        quote! {
            const _: () = {
                // Warning: This type doesn't have #[repr(C)]
                // GPU layout may differ from Rust layout
            };
        }
    };

    let size_check = quote! {
        const _: () = {
            // Compile-time size assertion
            let _ = core::mem::size_of::<#name>();
        };
    };

    let align_impl = if let Some(align) = custom_align {
        quote! {
            const ALIGNMENT: usize = #align;
        }
    } else {
        quote! {
            const ALIGNMENT: usize = core::mem::align_of::<Self>();
        }
    };

    let expanded = quote! {
        #validation
        #size_check

        // Safety: This is generated by the derive macro which ensures
        // the type is Copy and has a well-defined layout
        unsafe impl #impl_generics lumina::types::GpuData for #name #ty_generics #where_clause {
            #align_impl

            fn size() -> usize {
                core::mem::size_of::<Self>()
            }

            fn as_bytes(&self) -> &[u8] {
                unsafe {
                    core::slice::from_raw_parts(
                        self as *const Self as *const u8,
                        core::mem::size_of::<Self>()
                    )
                }
            }
        }
    };

    TokenStream::from(expanded)
}

/// Derive macro for `GpuVertex` trait
///
/// Generates vertex attribute descriptions for pipeline creation.
///
/// # Example
///
/// ```rust
/// #[derive(Clone, Copy, GpuVertex)]
/// struct Vertex {
///     #[location(0)]
///     position: Vec3,
///     #[location(1)]
///     normal: Vec3,
///     #[location(2)]
///     uv: Vec2,
/// }
/// ```
#[proc_macro_derive(GpuVertex, attributes(location))]
pub fn derive_gpu_vertex(input: TokenStream) -> TokenStream {
    let input = parse_macro_input!(input as DeriveInput);
    let name = &input.ident;
    let (impl_generics, ty_generics, where_clause) = input.generics.split_for_impl();

    // Extract fields and their locations
    let fields = match &input.data {
        syn::Data::Struct(data) => match &data.fields {
            syn::Fields::Named(fields) => &fields.named,
            _ => panic!("GpuVertex only supports structs with named fields"),
        },
        _ => panic!("GpuVertex only supports structs"),
    };

    let mut attributes = Vec::new();
    let mut offset = 0u32;
    let mut location = 0u32;

    for field in fields {
        let field_name = field.ident.as_ref().unwrap();
        let field_type = &field.ty;

        // Check for #[location(N)] attribute
        for attr in &field.attrs {
            if attr.path().is_ident("location") {
                let loc: syn::LitInt = attr.parse_args().unwrap();
                location = loc.base10_parse().unwrap();
            }
        }

        // Determine format from type
        let (format, size) = type_to_format_and_size(field_type);

        attributes.push(quote! {
            lumina::types::VertexAttribute {
                location: #location,
                offset: #offset,
                format: #format,
            }
        });

        offset += size;
        location += 1;
    }

    let attr_count = attributes.len();

    let expanded = quote! {
        // Safety: Generated by derive macro
        unsafe impl #impl_generics lumina::types::GpuData for #name #ty_generics #where_clause {}

        impl #impl_generics lumina::types::GpuVertex for #name #ty_generics #where_clause {
            fn attributes() -> &'static [lumina::types::VertexAttribute] {
                static ATTRS: [lumina::types::VertexAttribute; #attr_count] = [
                    #(#attributes),*
                ];
                &ATTRS
            }
        }
    };

    TokenStream::from(expanded)
}

/// Derive macro for `GpuUniforms` trait
///
/// Generates uniform buffer layout information.
///
/// # Example
///
/// ```rust
/// #[derive(Clone, Copy, GpuUniforms)]
/// struct SceneUniforms {
///     model: Mat4,
///     view: Mat4,
///     projection: Mat4,
///     time: f32,
/// }
/// ```
#[proc_macro_derive(GpuUniforms)]
pub fn derive_gpu_uniforms(input: TokenStream) -> TokenStream {
    let input = parse_macro_input!(input as DeriveInput);
    let name = &input.ident;
    let (impl_generics, ty_generics, where_clause) = input.generics.split_for_impl();

    // Extract fields
    let fields = match &input.data {
        syn::Data::Struct(data) => match &data.fields {
            syn::Fields::Named(fields) => &fields.named,
            _ => panic!("GpuUniforms only supports structs with named fields"),
        },
        _ => panic!("GpuUniforms only supports structs"),
    };

    let mut members = Vec::new();
    let mut offset = 0u32;

    for field in fields {
        let field_name = field.ident.as_ref().unwrap();
        let field_name_str = field_name.to_string();
        let field_type = &field.ty;

        let (uniform_type, size, alignment) = type_to_uniform_info(field_type);

        // Align offset
        offset = (offset + alignment - 1) & !(alignment - 1);

        members.push(quote! {
            lumina::types::UniformMember {
                name: #field_name_str,
                offset: #offset,
                size: #size,
                ty: #uniform_type,
            }
        });

        offset += size;
    }

    let member_count = members.len();

    let expanded = quote! {
        // Safety: Generated by derive macro
        unsafe impl #impl_generics lumina::types::GpuData for #name #ty_generics #where_clause {}

        impl #impl_generics lumina::types::GpuUniforms for #name #ty_generics #where_clause {
            fn layout() -> &'static [lumina::types::UniformMember] {
                static LAYOUT: [lumina::types::UniformMember; #member_count] = [
                    #(#members),*
                ];
                &LAYOUT
            }
        }
    };

    TokenStream::from(expanded)
}

/// Attribute macro for shader functions
///
/// Transforms a Rust function into a GPU shader.
///
/// # Example
///
/// ```rust
/// #[lumina::shader(vertex)]
/// fn vertex_main(pos: Vec3, color: Vec3) -> VertexOutput<Vec3> {
///     VertexOutput {
///         position: pos.extend(1.0),
///         varying: color,
///     }
/// }
/// ```
#[proc_macro_attribute]
pub fn shader(attr: TokenStream, item: TokenStream) -> TokenStream {
    let _attr = attr.to_string();
    let input = parse_macro_input!(item as ItemFn);
    let name = &input.sig.ident;
    let vis = &input.vis;

    // For now, just generate a marker struct
    // Full implementation would use rust-gpu or similar
    let expanded = quote! {
        #vis struct #name;

        impl #name {
            pub const fn spirv() -> &'static [u32] {
                // Placeholder - would contain actual SPIR-V
                &[]
            }
        }
    };

    TokenStream::from(expanded)
}

/// Helper to convert a Rust type to AttributeFormat and size
fn type_to_format_and_size(ty: &syn::Type) -> (proc_macro2::TokenStream, u32) {
    let type_str = quote!(#ty).to_string().replace(' ', "");

    match type_str.as_str() {
        "f32" => (quote!(lumina::types::AttributeFormat::Float), 4),
        "Vec2" | "lumina::math::Vec2" => (quote!(lumina::types::AttributeFormat::Vec2), 8),
        "Vec3" | "lumina::math::Vec3" => (quote!(lumina::types::AttributeFormat::Vec3), 12),
        "Vec4" | "lumina::math::Vec4" => (quote!(lumina::types::AttributeFormat::Vec4), 16),
        "i32" => (quote!(lumina::types::AttributeFormat::Int), 4),
        "u32" => (quote!(lumina::types::AttributeFormat::UInt), 4),
        "[f32;2]" => (quote!(lumina::types::AttributeFormat::Vec2), 8),
        "[f32;3]" => (quote!(lumina::types::AttributeFormat::Vec3), 12),
        "[f32;4]" => (quote!(lumina::types::AttributeFormat::Vec4), 16),
        _ => (quote!(lumina::types::AttributeFormat::Vec4), 16),
    }
}

/// Helper to convert a Rust type to UniformType, size, and alignment
fn type_to_uniform_info(ty: &syn::Type) -> (proc_macro2::TokenStream, u32, u32) {
    let type_str = quote!(#ty).to_string().replace(' ', "");

    match type_str.as_str() {
        "f32" => (quote!(lumina::types::UniformType::Float), 4, 4),
        "Vec2" | "lumina::math::Vec2" => (quote!(lumina::types::UniformType::Vec2), 8, 8),
        "Vec3" | "lumina::math::Vec3" => (quote!(lumina::types::UniformType::Vec3), 12, 16),
        "Vec4" | "lumina::math::Vec4" => (quote!(lumina::types::UniformType::Vec4), 16, 16),
        "i32" => (quote!(lumina::types::UniformType::Int), 4, 4),
        "u32" => (quote!(lumina::types::UniformType::UInt), 4, 4),
        "Mat2" | "lumina::math::Mat2" => (quote!(lumina::types::UniformType::Mat2), 16, 8),
        "Mat3" | "lumina::math::Mat3" => (quote!(lumina::types::UniformType::Mat3), 48, 16),
        "Mat4" | "lumina::math::Mat4" => (quote!(lumina::types::UniformType::Mat4), 64, 16),
        "bool" => (quote!(lumina::types::UniformType::Bool), 4, 4),
        "IVec2" | "lumina::math::IVec2" => (quote!(lumina::types::UniformType::IVec2), 8, 8),
        "IVec3" | "lumina::math::IVec3" => (quote!(lumina::types::UniformType::IVec3), 12, 16),
        "IVec4" | "lumina::math::IVec4" => (quote!(lumina::types::UniformType::IVec4), 16, 16),
        "UVec2" | "lumina::math::UVec2" => (quote!(lumina::types::UniformType::UVec2), 8, 8),
        "UVec3" | "lumina::math::UVec3" => (quote!(lumina::types::UniformType::UVec3), 12, 16),
        "UVec4" | "lumina::math::UVec4" => (quote!(lumina::types::UniformType::UVec4), 16, 16),
        _ => (quote!(lumina::types::UniformType::Struct), 16, 16),
    }
}

/// Parse #[gpu(align = N)] attribute
fn parse_gpu_align(attrs: &[Attribute]) -> Option<usize> {
    for attr in attrs {
        if attr.path().is_ident("gpu") {
            if let Ok(meta) = attr.meta.require_list() {
                let tokens = meta.tokens.to_string();
                if tokens.starts_with("align") {
                    // Extract number after =
                    if let Some(num_str) = tokens.split('=').nth(1) {
                        if let Ok(num) = num_str.trim().parse::<usize>() {
                            return Some(num);
                        }
                    }
                }
            }
        }
    }
    None
}

/// Parse #[binding(N)] attribute
fn parse_binding(attrs: &[Attribute]) -> Option<u32> {
    for attr in attrs {
        if attr.path().is_ident("binding") {
            if let Ok(lit) = attr.parse_args::<syn::LitInt>() {
                if let Ok(num) = lit.base10_parse::<u32>() {
                    return Some(num);
                }
            }
        }
    }
    None
}

/// Parse #[set(N)] attribute
fn parse_set(attrs: &[Attribute]) -> Option<u32> {
    for attr in attrs {
        if attr.path().is_ident("set") {
            if let Ok(lit) = attr.parse_args::<syn::LitInt>() {
                if let Ok(num) = lit.base10_parse::<u32>() {
                    return Some(num);
                }
            }
        }
    }
    None
}

/// Derive macro for `GpuPushConstants` trait
///
/// Push constants are small, fast-path data passed directly in the command buffer.
/// Limited to 128 bytes on most hardware.
///
/// # Example
///
/// ```rust
/// #[repr(C)]
/// #[derive(Clone, Copy, GpuPushConstants)]
/// struct PushData {
///     model_matrix: Mat4,
///     color: Vec4,
/// }
/// ```
#[proc_macro_derive(GpuPushConstants, attributes(gpu))]
pub fn derive_gpu_push_constants(input: TokenStream) -> TokenStream {
    let input = parse_macro_input!(input as DeriveInput);
    let name = &input.ident;
    let (impl_generics, ty_generics, where_clause) = input.generics.split_for_impl();

    let expanded = quote! {
        // Safety: Generated by derive macro, validated for push constant rules
        unsafe impl #impl_generics lumina::types::GpuData for #name #ty_generics #where_clause {
            const ALIGNMENT: usize = 4;

            fn size() -> usize {
                core::mem::size_of::<Self>()
            }

            fn as_bytes(&self) -> &[u8] {
                unsafe {
                    core::slice::from_raw_parts(
                        self as *const Self as *const u8,
                        core::mem::size_of::<Self>()
                    )
                }
            }
        }

        impl #impl_generics lumina::types::GpuPushConstants for #name #ty_generics #where_clause {
            const SIZE: usize = core::mem::size_of::<Self>();

            const _SIZE_CHECK: () = {
                // Push constants typically limited to 128 bytes
                assert!(core::mem::size_of::<Self>() <= 128,
                    "Push constants must be <= 128 bytes");
            };
        }
    };

    TokenStream::from(expanded)
}

/// Derive macro for `GpuStorage` trait
///
/// Storage buffers are read/write capable buffers for compute shaders
/// and large data sets.
///
/// # Example
///
/// ```rust
/// #[repr(C)]
/// #[derive(Clone, Copy, GpuStorage)]
/// struct ComputeData {
///     #[binding(0)]
///     values: [f32; 1024],
/// }
/// ```
#[proc_macro_derive(GpuStorage, attributes(binding, set))]
pub fn derive_gpu_storage(input: TokenStream) -> TokenStream {
    let input = parse_macro_input!(input as DeriveInput);
    let name = &input.ident;
    let (impl_generics, ty_generics, where_clause) = input.generics.split_for_impl();

    let binding = parse_binding(&input.attrs).unwrap_or(0);
    let set = parse_set(&input.attrs).unwrap_or(0);

    let expanded = quote! {
        // Safety: Generated by derive macro
        unsafe impl #impl_generics lumina::types::GpuData for #name #ty_generics #where_clause {
            const ALIGNMENT: usize = 16; // std430 alignment

            fn size() -> usize {
                core::mem::size_of::<Self>()
            }

            fn as_bytes(&self) -> &[u8] {
                unsafe {
                    core::slice::from_raw_parts(
                        self as *const Self as *const u8,
                        core::mem::size_of::<Self>()
                    )
                }
            }
        }

        impl #impl_generics lumina::types::GpuStorage for #name #ty_generics #where_clause {
            const BINDING: u32 = #binding;
            const SET: u32 = #set;
        }
    };

    TokenStream::from(expanded)
}

/// Derive macro for `GpuTexture` bindings
///
/// # Example
///
/// ```rust
/// #[derive(GpuTextureBinding)]
/// struct TextureBindings {
///     #[binding(0)]
///     albedo: Texture2D,
///     #[binding(1)]
///     normal: Texture2D,
///     #[binding(2)]
///     roughness: Texture2D,
/// }
/// ```
#[proc_macro_derive(GpuTextureBinding, attributes(binding, set))]
pub fn derive_gpu_texture_binding(input: TokenStream) -> TokenStream {
    let input = parse_macro_input!(input as DeriveInput);
    let name = &input.ident;
    let (impl_generics, ty_generics, where_clause) = input.generics.split_for_impl();

    let fields = match &input.data {
        Data::Struct(data) => match &data.fields {
            Fields::Named(fields) => &fields.named,
            _ => panic!("GpuTextureBinding only supports structs with named fields"),
        },
        _ => panic!("GpuTextureBinding only supports structs"),
    };

    let mut bindings = Vec::new();
    
    for field in fields {
        let field_name = field.ident.as_ref().unwrap();
        let field_name_str = field_name.to_string();
        let binding = parse_binding(&field.attrs).unwrap_or(bindings.len() as u32);

        bindings.push(quote! {
            lumina::types::TextureBindingInfo {
                name: #field_name_str,
                binding: #binding,
            }
        });
    }

    let binding_count = bindings.len();

    let expanded = quote! {
        impl #impl_generics lumina::types::GpuTextureBinding for #name #ty_generics #where_clause {
            fn bindings() -> &'static [lumina::types::TextureBindingInfo] {
                static BINDINGS: [lumina::types::TextureBindingInfo; #binding_count] = [
                    #(#bindings),*
                ];
                &BINDINGS
            }
        }
    };

    TokenStream::from(expanded)
}

/// Attribute macro for compute shader workgroup configuration
///
/// # Example
///
/// ```rust
/// #[lumina::compute(local_size = (8, 8, 1))]
/// fn my_compute(global_id: UVec3, local_id: UVec3) {
///     // ...
/// }
/// ```
#[proc_macro_attribute]
pub fn compute(attr: TokenStream, item: TokenStream) -> TokenStream {
    let attr_str = attr.to_string();
    let input = parse_macro_input!(item as ItemFn);
    let name = &input.sig.ident;
    let vis = &input.vis;

    // Parse local_size
    let (x, y, z) = parse_local_size(&attr_str).unwrap_or((1, 1, 1));

    let expanded = quote! {
        #vis struct #name;

        impl #name {
            pub const LOCAL_SIZE_X: u32 = #x;
            pub const LOCAL_SIZE_Y: u32 = #y;
            pub const LOCAL_SIZE_Z: u32 = #z;

            pub const fn spirv() -> &'static [u32] {
                // Placeholder - would contain actual SPIR-V
                &[]
            }

            pub const fn local_size() -> (u32, u32, u32) {
                (Self::LOCAL_SIZE_X, Self::LOCAL_SIZE_Y, Self::LOCAL_SIZE_Z)
            }
        }
    };

    TokenStream::from(expanded)
}

/// Parse local_size attribute
fn parse_local_size(attr: &str) -> Option<(u32, u32, u32)> {
    // Simple parser for local_size = (x, y, z)
    if let Some(start) = attr.find('(') {
        if let Some(end) = attr.find(')') {
            let nums: Vec<&str> = attr[start+1..end].split(',').collect();
            if nums.len() == 3 {
                let x = nums[0].trim().parse().ok()?;
                let y = nums[1].trim().parse().ok()?;
                let z = nums[2].trim().parse().ok()?;
                return Some((x, y, z));
            }
        }
    }
    None
}

//! # Framebuffer Driver for Helix OS
//!
//! This module provides a simple framebuffer driver that works with
//! linear framebuffers provided by Limine/Multiboot2 bootloaders.
//!
//! ## Architecture
//!
//! ```text
//! ┌─────────────────────────────────────────────────────────────────────┐
//! │                    FRAMEBUFFER MEMORY LAYOUT                        │
//! ├─────────────────────────────────────────────────────────────────────┤
//! │                                                                     │
//! │  Physical Address (from bootloader)                                 │
//! │  ┌─────────────────────────────────────────────────────────────┐   │
//! │  │ Pixel (0,0)  │ Pixel (1,0)  │ ... │ Pixel (width-1, 0)      │   │
//! │  │ BGRA 32-bit  │ BGRA 32-bit  │     │ BGRA 32-bit             │   │
//! │  ├──────────────┴──────────────┴─────┴─────────────────────────┤   │
//! │  │ <───────────────── pitch (bytes per line) ─────────────────>│   │
//! │  ├─────────────────────────────────────────────────────────────┤   │
//! │  │ Pixel (0,1)  │ Pixel (1,1)  │ ... │ Pixel (width-1, 1)      │   │
//! │  └─────────────────────────────────────────────────────────────┘   │
//! │                                                                     │
//! └─────────────────────────────────────────────────────────────────────┘
//! ```

use core::sync::atomic::{AtomicBool, AtomicU64, AtomicU32, Ordering};

/// Global framebuffer state
static FB_INITIALIZED: AtomicBool = AtomicBool::new(false);
static FB_ADDR: AtomicU64 = AtomicU64::new(0);
static FB_WIDTH: AtomicU32 = AtomicU32::new(0);
static FB_HEIGHT: AtomicU32 = AtomicU32::new(0);
static FB_PITCH: AtomicU32 = AtomicU32::new(0);
static FB_BPP: AtomicU32 = AtomicU32::new(0);

/// Framebuffer information structure
#[derive(Debug, Clone, Copy)]
pub struct FramebufferInfo {
    /// Physical address of framebuffer
    pub addr: u64,
    /// Width in pixels
    pub width: u32,
    /// Height in pixels
    pub height: u32,
    /// Bytes per scanline (pitch)
    pub pitch: u32,
    /// Bits per pixel (usually 32)
    pub bpp: u32,
}

/// Color in BGRA format (common for x86 framebuffers)
#[derive(Debug, Clone, Copy)]
#[repr(C)]
pub struct Color {
    pub blue: u8,
    pub green: u8,
    pub red: u8,
    pub alpha: u8,
}

impl Color {
    pub const fn new(red: u8, green: u8, blue: u8) -> Self {
        Self { red, green, blue, alpha: 255 }
    }

    pub const fn rgb(red: u8, green: u8, blue: u8) -> Self {
        Self::new(red, green, blue)
    }

    // Predefined colors
    pub const BLACK: Color = Color::rgb(0, 0, 0);
    pub const WHITE: Color = Color::rgb(255, 255, 255);
    pub const RED: Color = Color::rgb(255, 0, 0);
    pub const GREEN: Color = Color::rgb(0, 255, 0);
    pub const BLUE: Color = Color::rgb(0, 0, 255);
    pub const YELLOW: Color = Color::rgb(255, 255, 0);
    pub const CYAN: Color = Color::rgb(0, 255, 255);
    pub const MAGENTA: Color = Color::rgb(255, 0, 255);
    pub const ORANGE: Color = Color::rgb(255, 165, 0);
    pub const HELIX_PURPLE: Color = Color::rgb(138, 43, 226);
}

impl From<u32> for Color {
    fn from(value: u32) -> Self {
        Self {
            blue: (value & 0xFF) as u8,
            green: ((value >> 8) & 0xFF) as u8,
            red: ((value >> 16) & 0xFF) as u8,
            alpha: ((value >> 24) & 0xFF) as u8,
        }
    }
}

impl From<Color> for u32 {
    fn from(c: Color) -> Self {
        (c.alpha as u32) << 24 | (c.red as u32) << 16 | (c.green as u32) << 8 | c.blue as u32
    }
}

/// Initialize framebuffer with given parameters
///
/// # Safety
/// The address must point to valid framebuffer memory
pub unsafe fn init(info: FramebufferInfo) {
    FB_ADDR.store(info.addr, Ordering::SeqCst);
    FB_WIDTH.store(info.width, Ordering::SeqCst);
    FB_HEIGHT.store(info.height, Ordering::SeqCst);
    FB_PITCH.store(info.pitch, Ordering::SeqCst);
    FB_BPP.store(info.bpp, Ordering::SeqCst);
    FB_INITIALIZED.store(true, Ordering::SeqCst);

    crate::serial_write_str("  [FB] Framebuffer initialized: ");
    crate::print_num(info.width as u64);
    crate::serial_write_str("x");
    crate::print_num(info.height as u64);
    crate::serial_write_str("x");
    crate::print_num(info.bpp as u64);
    crate::serial_write_str(" @ 0x");
    crate::print_hex(info.addr);
    crate::serial_write_str("\n");
}

/// Check if framebuffer is initialized
pub fn is_initialized() -> bool {
    FB_INITIALIZED.load(Ordering::SeqCst)
}

/// Get framebuffer info
pub fn get_info() -> Option<FramebufferInfo> {
    if !is_initialized() {
        return None;
    }
    Some(FramebufferInfo {
        addr: FB_ADDR.load(Ordering::SeqCst),
        width: FB_WIDTH.load(Ordering::SeqCst),
        height: FB_HEIGHT.load(Ordering::SeqCst),
        pitch: FB_PITCH.load(Ordering::SeqCst),
        bpp: FB_BPP.load(Ordering::SeqCst),
    })
}

/// Put a pixel at (x, y) with given color
///
/// # Safety
/// Assumes framebuffer is properly initialized and mapped
#[inline]
pub unsafe fn put_pixel(x: u32, y: u32, color: Color) {
    if !is_initialized() {
        return;
    }

    let width = FB_WIDTH.load(Ordering::Relaxed);
    let height = FB_HEIGHT.load(Ordering::Relaxed);

    if x >= width || y >= height {
        return;
    }

    let addr = FB_ADDR.load(Ordering::Relaxed);
    let pitch = FB_PITCH.load(Ordering::Relaxed);
    let bpp = FB_BPP.load(Ordering::Relaxed);

    let bytes_per_pixel = bpp / 8;
    let offset = (y as u64 * pitch as u64) + (x as u64 * bytes_per_pixel as u64);
    let pixel_addr = (addr + offset) as *mut u32;

    *pixel_addr = color.into();
}

/// Fill the entire screen with a color
pub unsafe fn clear(color: Color) {
    if !is_initialized() {
        return;
    }

    let addr = FB_ADDR.load(Ordering::Relaxed);
    let width = FB_WIDTH.load(Ordering::Relaxed);
    let height = FB_HEIGHT.load(Ordering::Relaxed);
    let pitch = FB_PITCH.load(Ordering::Relaxed);

    let color_val: u32 = color.into();

    for y in 0..height {
        for x in 0..width {
            let offset = (y as u64 * pitch as u64) + (x as u64 * 4);
            let pixel = (addr + offset) as *mut u32;
            *pixel = color_val;
        }
    }
}

/// Draw a filled rectangle
pub unsafe fn fill_rect(x: u32, y: u32, w: u32, h: u32, color: Color) {
    if !is_initialized() {
        return;
    }

    let width = FB_WIDTH.load(Ordering::Relaxed);
    let height = FB_HEIGHT.load(Ordering::Relaxed);

    let color_val: u32 = color.into();

    for dy in 0..h {
        let py = y + dy;
        if py >= height {
            break;
        }
        for dx in 0..w {
            let px = x + dx;
            if px >= width {
                break;
            }
            put_pixel(px, py, color);
        }
    }
}

/// Draw a horizontal gradient bar (for boot splash)
pub unsafe fn draw_gradient_bar(x: u32, y: u32, w: u32, h: u32) {
    if !is_initialized() {
        return;
    }

    for dx in 0..w {
        let ratio = (dx as f32) / (w as f32);
        let r = (138.0 + (255.0 - 138.0) * ratio) as u8;  // Purple to orange
        let g = (43.0 + (165.0 - 43.0) * ratio) as u8;
        let b = (226.0 - 226.0 * ratio) as u8;

        let color = Color::rgb(r, g, b);
        for dy in 0..h {
            put_pixel(x + dx, y + dy, color);
        }
    }
}

/// Draw the Helix OS boot splash screen
pub unsafe fn draw_boot_splash() {
    if !is_initialized() {
        crate::serial_write_str("  [FB] Cannot draw splash - framebuffer not initialized\n");
        return;
    }

    crate::serial_write_str("  [FB] Drawing boot splash...\n");

    let width = FB_WIDTH.load(Ordering::Relaxed);
    let height = FB_HEIGHT.load(Ordering::Relaxed);

    // Clear to dark background
    clear(Color::rgb(20, 20, 30));

    // Draw gradient bar at center
    let bar_width = width * 2 / 3;
    let bar_height = 40;
    let bar_x = (width - bar_width) / 2;
    let bar_y = height / 2;

    draw_gradient_bar(bar_x, bar_y, bar_width, bar_height);

    // Draw border around bar
    let border_color = Color::WHITE;
    // Top border
    for x in bar_x..bar_x + bar_width {
        put_pixel(x, bar_y - 1, border_color);
    }
    // Bottom border
    for x in bar_x..bar_x + bar_width {
        put_pixel(x, bar_y + bar_height, border_color);
    }
    // Left border
    for y in bar_y - 1..bar_y + bar_height + 1 {
        put_pixel(bar_x - 1, y, border_color);
    }
    // Right border
    for y in bar_y - 1..bar_y + bar_height + 1 {
        put_pixel(bar_x + bar_width, y, border_color);
    }

    // Draw "HELIX" text pattern at top (simple pixel art)
    draw_helix_logo(width / 2 - 100, height / 3);

    crate::serial_write_str("  [FB] Boot splash complete!\n");
}

/// Draw a simple "HELIX" pixel art logo
unsafe fn draw_helix_logo(x: u32, y: u32) {
    let color = Color::HELIX_PURPLE;

    // 'H'
    for i in 0..20 { put_pixel(x, y + i, color); }
    for i in 0..20 { put_pixel(x + 10, y + i, color); }
    for i in 0..11 { put_pixel(x + i, y + 10, color); }

    // 'E'
    for i in 0..20 { put_pixel(x + 20, y + i, color); }
    for i in 0..10 { put_pixel(x + 20 + i, y, color); }
    for i in 0..10 { put_pixel(x + 20 + i, y + 10, color); }
    for i in 0..10 { put_pixel(x + 20 + i, y + 19, color); }

    // 'L'
    for i in 0..20 { put_pixel(x + 40, y + i, color); }
    for i in 0..10 { put_pixel(x + 40 + i, y + 19, color); }

    // 'I'
    for i in 0..10 { put_pixel(x + 60 + i, y, color); }
    for i in 0..20 { put_pixel(x + 65, y + i, color); }
    for i in 0..10 { put_pixel(x + 60 + i, y + 19, color); }

    // 'X'
    for i in 0..20 {
        put_pixel(x + 80 + i / 2, y + i, color);
        put_pixel(x + 90 - i / 2, y + i, color);
    }
}

/// Test pattern for debugging - draw colored corners
pub unsafe fn draw_test_pattern() {
    if !is_initialized() {
        return;
    }

    crate::serial_write_str("  [FB] Drawing test pattern...\n");

    let width = FB_WIDTH.load(Ordering::Relaxed);
    let height = FB_HEIGHT.load(Ordering::Relaxed);
    let size = 50;

    // Top-left: Red
    fill_rect(0, 0, size, size, Color::RED);

    // Top-right: Green
    fill_rect(width - size, 0, size, size, Color::GREEN);

    // Bottom-left: Blue
    fill_rect(0, height - size, size, size, Color::BLUE);

    // Bottom-right: Yellow
    fill_rect(width - size, height - size, size, size, Color::YELLOW);

    // Center: White
    fill_rect(width / 2 - size / 2, height / 2 - size / 2, size, size, Color::WHITE);

    crate::serial_write_str("  [FB] Test pattern complete!\n");
}

// =============================================================================
// GRAPHICAL TEXT CONSOLE
// =============================================================================

/// 8x16 bitmap font (basic ASCII, characters 32-126)
/// Each character is 8 pixels wide and 16 pixels tall
/// Each row of a character is stored as 1 byte (8 bits = 8 pixels)
static FONT_8X16: [u8; 95 * 16] = [
    // Space (32)
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    // ! (33)
    0x00, 0x00, 0x18, 0x3C, 0x3C, 0x3C, 0x18, 0x18, 0x18, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00,
    // " (34)
    0x00, 0x66, 0x66, 0x66, 0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    // # (35)
    0x00, 0x00, 0x00, 0x6C, 0x6C, 0xFE, 0x6C, 0x6C, 0x6C, 0xFE, 0x6C, 0x6C, 0x00, 0x00, 0x00, 0x00,
    // $ (36)
    0x18, 0x18, 0x7C, 0xC6, 0xC2, 0xC0, 0x7C, 0x06, 0x06, 0x86, 0xC6, 0x7C, 0x18, 0x18, 0x00, 0x00,
    // % (37)
    0x00, 0x00, 0x00, 0x00, 0xC2, 0xC6, 0x0C, 0x18, 0x30, 0x60, 0xC6, 0x86, 0x00, 0x00, 0x00, 0x00,
    // & (38)
    0x00, 0x00, 0x38, 0x6C, 0x6C, 0x38, 0x76, 0xDC, 0xCC, 0xCC, 0xCC, 0x76, 0x00, 0x00, 0x00, 0x00,
    // ' (39)
    0x00, 0x30, 0x30, 0x30, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    // ( (40)
    0x00, 0x00, 0x0C, 0x18, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x18, 0x0C, 0x00, 0x00, 0x00, 0x00,
    // ) (41)
    0x00, 0x00, 0x30, 0x18, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x18, 0x30, 0x00, 0x00, 0x00, 0x00,
    // * (42)
    0x00, 0x00, 0x00, 0x00, 0x00, 0x66, 0x3C, 0xFF, 0x3C, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    // + (43)
    0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x7E, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    // , (44)
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x18, 0x30, 0x00, 0x00, 0x00,
    // - (45)
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    // . (46)
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00,
    // / (47)
    0x00, 0x00, 0x00, 0x00, 0x02, 0x06, 0x0C, 0x18, 0x30, 0x60, 0xC0, 0x80, 0x00, 0x00, 0x00, 0x00,
    // 0 (48)
    0x00, 0x00, 0x3C, 0x66, 0xC3, 0xC3, 0xDB, 0xDB, 0xC3, 0xC3, 0x66, 0x3C, 0x00, 0x00, 0x00, 0x00,
    // 1 (49)
    0x00, 0x00, 0x18, 0x38, 0x78, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x7E, 0x00, 0x00, 0x00, 0x00,
    // 2 (50)
    0x00, 0x00, 0x7C, 0xC6, 0x06, 0x0C, 0x18, 0x30, 0x60, 0xC0, 0xC6, 0xFE, 0x00, 0x00, 0x00, 0x00,
    // 3 (51)
    0x00, 0x00, 0x7C, 0xC6, 0x06, 0x06, 0x3C, 0x06, 0x06, 0x06, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00,
    // 4 (52)
    0x00, 0x00, 0x0C, 0x1C, 0x3C, 0x6C, 0xCC, 0xFE, 0x0C, 0x0C, 0x0C, 0x1E, 0x00, 0x00, 0x00, 0x00,
    // 5 (53)
    0x00, 0x00, 0xFE, 0xC0, 0xC0, 0xC0, 0xFC, 0x06, 0x06, 0x06, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00,
    // 6 (54)
    0x00, 0x00, 0x38, 0x60, 0xC0, 0xC0, 0xFC, 0xC6, 0xC6, 0xC6, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00,
    // 7 (55)
    0x00, 0x00, 0xFE, 0xC6, 0x06, 0x06, 0x0C, 0x18, 0x30, 0x30, 0x30, 0x30, 0x00, 0x00, 0x00, 0x00,
    // 8 (56)
    0x00, 0x00, 0x7C, 0xC6, 0xC6, 0xC6, 0x7C, 0xC6, 0xC6, 0xC6, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00,
    // 9 (57)
    0x00, 0x00, 0x7C, 0xC6, 0xC6, 0xC6, 0x7E, 0x06, 0x06, 0x06, 0x0C, 0x78, 0x00, 0x00, 0x00, 0x00,
    // : (58)
    0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00,
    // ; (59)
    0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00, 0x18, 0x18, 0x30, 0x00, 0x00, 0x00, 0x00,
    // < (60)
    0x00, 0x00, 0x00, 0x06, 0x0C, 0x18, 0x30, 0x60, 0x30, 0x18, 0x0C, 0x06, 0x00, 0x00, 0x00, 0x00,
    // = (61)
    0x00, 0x00, 0x00, 0x00, 0x00, 0x7E, 0x00, 0x00, 0x7E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    // > (62)
    0x00, 0x00, 0x00, 0x60, 0x30, 0x18, 0x0C, 0x06, 0x0C, 0x18, 0x30, 0x60, 0x00, 0x00, 0x00, 0x00,
    // ? (63)
    0x00, 0x00, 0x7C, 0xC6, 0xC6, 0x0C, 0x18, 0x18, 0x18, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00,
    // @ (64)
    0x00, 0x00, 0x00, 0x7C, 0xC6, 0xC6, 0xDE, 0xDE, 0xDE, 0xDC, 0xC0, 0x7C, 0x00, 0x00, 0x00, 0x00,
    // A (65)
    0x00, 0x00, 0x10, 0x38, 0x6C, 0xC6, 0xC6, 0xFE, 0xC6, 0xC6, 0xC6, 0xC6, 0x00, 0x00, 0x00, 0x00,
    // B (66)
    0x00, 0x00, 0xFC, 0x66, 0x66, 0x66, 0x7C, 0x66, 0x66, 0x66, 0x66, 0xFC, 0x00, 0x00, 0x00, 0x00,
    // C (67)
    0x00, 0x00, 0x3C, 0x66, 0xC2, 0xC0, 0xC0, 0xC0, 0xC0, 0xC2, 0x66, 0x3C, 0x00, 0x00, 0x00, 0x00,
    // D (68)
    0x00, 0x00, 0xF8, 0x6C, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x6C, 0xF8, 0x00, 0x00, 0x00, 0x00,
    // E (69)
    0x00, 0x00, 0xFE, 0x66, 0x62, 0x68, 0x78, 0x68, 0x60, 0x62, 0x66, 0xFE, 0x00, 0x00, 0x00, 0x00,
    // F (70)
    0x00, 0x00, 0xFE, 0x66, 0x62, 0x68, 0x78, 0x68, 0x60, 0x60, 0x60, 0xF0, 0x00, 0x00, 0x00, 0x00,
    // G (71)
    0x00, 0x00, 0x3C, 0x66, 0xC2, 0xC0, 0xC0, 0xDE, 0xC6, 0xC6, 0x66, 0x3A, 0x00, 0x00, 0x00, 0x00,
    // H (72)
    0x00, 0x00, 0xC6, 0xC6, 0xC6, 0xC6, 0xFE, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0x00, 0x00, 0x00, 0x00,
    // I (73)
    0x00, 0x00, 0x3C, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3C, 0x00, 0x00, 0x00, 0x00,
    // J (74)
    0x00, 0x00, 0x1E, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0xCC, 0xCC, 0xCC, 0x78, 0x00, 0x00, 0x00, 0x00,
    // K (75)
    0x00, 0x00, 0xE6, 0x66, 0x66, 0x6C, 0x78, 0x78, 0x6C, 0x66, 0x66, 0xE6, 0x00, 0x00, 0x00, 0x00,
    // L (76)
    0x00, 0x00, 0xF0, 0x60, 0x60, 0x60, 0x60, 0x60, 0x60, 0x62, 0x66, 0xFE, 0x00, 0x00, 0x00, 0x00,
    // M (77)
    0x00, 0x00, 0xC6, 0xEE, 0xFE, 0xFE, 0xD6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0x00, 0x00, 0x00, 0x00,
    // N (78)
    0x00, 0x00, 0xC6, 0xE6, 0xF6, 0xFE, 0xDE, 0xCE, 0xC6, 0xC6, 0xC6, 0xC6, 0x00, 0x00, 0x00, 0x00,
    // O (79)
    0x00, 0x00, 0x7C, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00,
    // P (80)
    0x00, 0x00, 0xFC, 0x66, 0x66, 0x66, 0x7C, 0x60, 0x60, 0x60, 0x60, 0xF0, 0x00, 0x00, 0x00, 0x00,
    // Q (81)
    0x00, 0x00, 0x7C, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xD6, 0xDE, 0x7C, 0x0C, 0x0E, 0x00, 0x00,
    // R (82)
    0x00, 0x00, 0xFC, 0x66, 0x66, 0x66, 0x7C, 0x6C, 0x66, 0x66, 0x66, 0xE6, 0x00, 0x00, 0x00, 0x00,
    // S (83)
    0x00, 0x00, 0x7C, 0xC6, 0xC6, 0x60, 0x38, 0x0C, 0x06, 0xC6, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00,
    // T (84)
    0x00, 0x00, 0xFF, 0xDB, 0x99, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3C, 0x00, 0x00, 0x00, 0x00,
    // U (85)
    0x00, 0x00, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00,
    // V (86)
    0x00, 0x00, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0x6C, 0x38, 0x10, 0x00, 0x00, 0x00, 0x00,
    // W (87)
    0x00, 0x00, 0xC6, 0xC6, 0xC6, 0xC6, 0xD6, 0xD6, 0xD6, 0xFE, 0xEE, 0x6C, 0x00, 0x00, 0x00, 0x00,
    // X (88)
    0x00, 0x00, 0xC6, 0xC6, 0x6C, 0x7C, 0x38, 0x38, 0x7C, 0x6C, 0xC6, 0xC6, 0x00, 0x00, 0x00, 0x00,
    // Y (89)
    0x00, 0x00, 0xC6, 0xC6, 0xC6, 0x6C, 0x38, 0x18, 0x18, 0x18, 0x18, 0x3C, 0x00, 0x00, 0x00, 0x00,
    // Z (90)
    0x00, 0x00, 0xFE, 0xC6, 0x86, 0x0C, 0x18, 0x30, 0x60, 0xC2, 0xC6, 0xFE, 0x00, 0x00, 0x00, 0x00,
    // [ (91)
    0x00, 0x00, 0x3C, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x3C, 0x00, 0x00, 0x00, 0x00,
    // \ (92)
    0x00, 0x00, 0x00, 0x80, 0xC0, 0x60, 0x30, 0x18, 0x0C, 0x06, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00,
    // ] (93)
    0x00, 0x00, 0x3C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x3C, 0x00, 0x00, 0x00, 0x00,
    // ^ (94)
    0x10, 0x38, 0x6C, 0xC6, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    // _ (95)
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00,
    // ` (96)
    0x30, 0x30, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    // a (97)
    0x00, 0x00, 0x00, 0x00, 0x00, 0x78, 0x0C, 0x7C, 0xCC, 0xCC, 0xCC, 0x76, 0x00, 0x00, 0x00, 0x00,
    // b (98)
    0x00, 0x00, 0xE0, 0x60, 0x60, 0x78, 0x6C, 0x66, 0x66, 0x66, 0x66, 0x7C, 0x00, 0x00, 0x00, 0x00,
    // c (99)
    0x00, 0x00, 0x00, 0x00, 0x00, 0x7C, 0xC6, 0xC0, 0xC0, 0xC0, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00,
    // d (100)
    0x00, 0x00, 0x1C, 0x0C, 0x0C, 0x3C, 0x6C, 0xCC, 0xCC, 0xCC, 0xCC, 0x76, 0x00, 0x00, 0x00, 0x00,
    // e (101)
    0x00, 0x00, 0x00, 0x00, 0x00, 0x7C, 0xC6, 0xFE, 0xC0, 0xC0, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00,
    // f (102)
    0x00, 0x00, 0x38, 0x6C, 0x64, 0x60, 0xF0, 0x60, 0x60, 0x60, 0x60, 0xF0, 0x00, 0x00, 0x00, 0x00,
    // g (103)
    0x00, 0x00, 0x00, 0x00, 0x00, 0x76, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x7C, 0x0C, 0xCC, 0x78, 0x00,
    // h (104)
    0x00, 0x00, 0xE0, 0x60, 0x60, 0x6C, 0x76, 0x66, 0x66, 0x66, 0x66, 0xE6, 0x00, 0x00, 0x00, 0x00,
    // i (105)
    0x00, 0x00, 0x18, 0x18, 0x00, 0x38, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3C, 0x00, 0x00, 0x00, 0x00,
    // j (106)
    0x00, 0x00, 0x06, 0x06, 0x00, 0x0E, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x66, 0x66, 0x3C, 0x00,
    // k (107)
    0x00, 0x00, 0xE0, 0x60, 0x60, 0x66, 0x6C, 0x78, 0x78, 0x6C, 0x66, 0xE6, 0x00, 0x00, 0x00, 0x00,
    // l (108)
    0x00, 0x00, 0x38, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3C, 0x00, 0x00, 0x00, 0x00,
    // m (109)
    0x00, 0x00, 0x00, 0x00, 0x00, 0xE6, 0xFF, 0xDB, 0xDB, 0xDB, 0xDB, 0xDB, 0x00, 0x00, 0x00, 0x00,
    // n (110)
    0x00, 0x00, 0x00, 0x00, 0x00, 0xDC, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00,
    // o (111)
    0x00, 0x00, 0x00, 0x00, 0x00, 0x7C, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00,
    // p (112)
    0x00, 0x00, 0x00, 0x00, 0x00, 0xDC, 0x66, 0x66, 0x66, 0x66, 0x66, 0x7C, 0x60, 0x60, 0xF0, 0x00,
    // q (113)
    0x00, 0x00, 0x00, 0x00, 0x00, 0x76, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x7C, 0x0C, 0x0C, 0x1E, 0x00,
    // r (114)
    0x00, 0x00, 0x00, 0x00, 0x00, 0xDC, 0x76, 0x66, 0x60, 0x60, 0x60, 0xF0, 0x00, 0x00, 0x00, 0x00,
    // s (115)
    0x00, 0x00, 0x00, 0x00, 0x00, 0x7C, 0xC6, 0x60, 0x38, 0x0C, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00,
    // t (116)
    0x00, 0x00, 0x10, 0x30, 0x30, 0xFC, 0x30, 0x30, 0x30, 0x30, 0x36, 0x1C, 0x00, 0x00, 0x00, 0x00,
    // u (117)
    0x00, 0x00, 0x00, 0x00, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x76, 0x00, 0x00, 0x00, 0x00,
    // v (118)
    0x00, 0x00, 0x00, 0x00, 0x00, 0xC6, 0xC6, 0xC6, 0xC6, 0x6C, 0x38, 0x10, 0x00, 0x00, 0x00, 0x00,
    // w (119)
    0x00, 0x00, 0x00, 0x00, 0x00, 0xC6, 0xC6, 0xD6, 0xD6, 0xD6, 0xFE, 0x6C, 0x00, 0x00, 0x00, 0x00,
    // x (120)
    0x00, 0x00, 0x00, 0x00, 0x00, 0xC6, 0x6C, 0x38, 0x38, 0x38, 0x6C, 0xC6, 0x00, 0x00, 0x00, 0x00,
    // y (121)
    0x00, 0x00, 0x00, 0x00, 0x00, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0x7E, 0x06, 0x0C, 0xF8, 0x00,
    // z (122)
    0x00, 0x00, 0x00, 0x00, 0x00, 0xFE, 0xCC, 0x18, 0x30, 0x60, 0xC6, 0xFE, 0x00, 0x00, 0x00, 0x00,
    // { (123)
    0x00, 0x00, 0x0E, 0x18, 0x18, 0x18, 0x70, 0x18, 0x18, 0x18, 0x18, 0x0E, 0x00, 0x00, 0x00, 0x00,
    // | (124)
    0x00, 0x00, 0x18, 0x18, 0x18, 0x18, 0x00, 0x18, 0x18, 0x18, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00,
    // } (125)
    0x00, 0x00, 0x70, 0x18, 0x18, 0x18, 0x0E, 0x18, 0x18, 0x18, 0x18, 0x70, 0x00, 0x00, 0x00, 0x00,
    // ~ (126)
    0x00, 0x00, 0x76, 0xDC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
];

/// Font dimensions
pub const FONT_WIDTH: u32 = 8;
pub const FONT_HEIGHT: u32 = 16;

/// Console state
use core::sync::atomic::AtomicUsize;

static CONSOLE_CURSOR_X: AtomicUsize = AtomicUsize::new(0);
static CONSOLE_CURSOR_Y: AtomicUsize = AtomicUsize::new(0);
static CONSOLE_INITIALIZED: AtomicBool = AtomicBool::new(false);

/// Console colors
static CONSOLE_FG: AtomicU32 = AtomicU32::new(0xFFCCCCCC); // Light gray
static CONSOLE_BG: AtomicU32 = AtomicU32::new(0xFF1A1A2E); // Dark blue-gray

/// Initialize the graphical console
pub fn console_init() {
    if !is_initialized() {
        return;
    }

    // Clear screen with background color
    let bg: Color = CONSOLE_BG.load(Ordering::Relaxed).into();
    unsafe { clear(bg); }

    CONSOLE_CURSOR_X.store(0, Ordering::SeqCst);
    CONSOLE_CURSOR_Y.store(0, Ordering::SeqCst);
    CONSOLE_INITIALIZED.store(true, Ordering::SeqCst);

    crate::serial_write_str("  [CONSOLE] Graphical console initialized\n");
}

/// Check if console is initialized
pub fn console_is_ready() -> bool {
    CONSOLE_INITIALIZED.load(Ordering::SeqCst) && is_initialized()
}

/// Get console dimensions in characters
pub fn console_size() -> (u32, u32) {
    let width = FB_WIDTH.load(Ordering::Relaxed);
    let height = FB_HEIGHT.load(Ordering::Relaxed);
    (width / FONT_WIDTH, height / FONT_HEIGHT)
}

/// Draw a single character at pixel position
pub unsafe fn draw_char(x: u32, y: u32, c: char, fg: Color, bg: Color) {
    if !is_initialized() {
        return;
    }

    // Get character index (ASCII 32-126)
    let idx = if c >= ' ' && c <= '~' {
        (c as usize) - 32
    } else {
        0 // Space for unknown characters
    };

    let glyph = &FONT_8X16[idx * 16..(idx + 1) * 16];

    for row in 0..16 {
        let bits = glyph[row];
        for col in 0..8 {
            let px = x + col;
            let py = y + row as u32;
            let color = if (bits >> (7 - col)) & 1 != 0 { fg } else { bg };
            put_pixel(px, py, color);
        }
    }
}

/// Write a character to the console at current cursor position
pub fn console_putchar(c: char) {
    if !console_is_ready() {
        return;
    }

    let (cols, rows) = console_size();
    let mut cx = CONSOLE_CURSOR_X.load(Ordering::SeqCst);
    let mut cy = CONSOLE_CURSOR_Y.load(Ordering::SeqCst);

    let fg: Color = CONSOLE_FG.load(Ordering::Relaxed).into();
    let bg: Color = CONSOLE_BG.load(Ordering::Relaxed).into();

    match c {
        '\n' => {
            cx = 0;
            cy += 1;
        }
        '\r' => {
            cx = 0;
        }
        '\t' => {
            cx = (cx + 8) & !7;
        }
        _ => {
            let px = (cx as u32) * FONT_WIDTH;
            let py = (cy as u32) * FONT_HEIGHT;
            unsafe { draw_char(px, py, c, fg, bg); }
            cx += 1;
        }
    }

    // Handle line wrap
    if cx >= cols as usize {
        cx = 0;
        cy += 1;
    }

    // Handle scroll
    if cy >= rows as usize {
        console_scroll();
        cy = rows as usize - 1;
    }

    CONSOLE_CURSOR_X.store(cx, Ordering::SeqCst);
    CONSOLE_CURSOR_Y.store(cy, Ordering::SeqCst);
}

/// Scroll the console up by one line
fn console_scroll() {
    if !is_initialized() {
        return;
    }

    let addr = FB_ADDR.load(Ordering::Relaxed);
    let width = FB_WIDTH.load(Ordering::Relaxed);
    let height = FB_HEIGHT.load(Ordering::Relaxed);
    let pitch = FB_PITCH.load(Ordering::Relaxed);

    let line_height = FONT_HEIGHT as usize;
    let bytes_per_line = pitch as usize;

    // Copy lines up
    unsafe {
        let fb = addr as *mut u8;
        let lines_to_copy = height as usize - line_height;

        for y in 0..lines_to_copy {
            let src_offset = (y + line_height) * bytes_per_line;
            let dst_offset = y * bytes_per_line;
            core::ptr::copy(
                fb.add(src_offset),
                fb.add(dst_offset),
                bytes_per_line
            );
        }

        // Clear bottom line
        let bg: Color = CONSOLE_BG.load(Ordering::Relaxed).into();
        let bg_val: u32 = bg.into();
        for y in (height as usize - line_height)..height as usize {
            for x in 0..width as usize {
                let offset = y * bytes_per_line + x * 4;
                let pixel = fb.add(offset) as *mut u32;
                *pixel = bg_val;
            }
        }
    }
}

/// Write a string to the console
pub fn console_write_str(s: &str) {
    for c in s.chars() {
        // Skip ANSI escape sequences for now
        if c == '\x1b' {
            // TODO: Parse ANSI codes for colors
            continue;
        }
        console_putchar(c);
    }
}

/// Clear the console
pub fn console_clear() {
    if !console_is_ready() {
        return;
    }

    let bg: Color = CONSOLE_BG.load(Ordering::Relaxed).into();
    unsafe { clear(bg); }

    CONSOLE_CURSOR_X.store(0, Ordering::SeqCst);
    CONSOLE_CURSOR_Y.store(0, Ordering::SeqCst);
}

/// Set console colors
pub fn console_set_colors(fg: Color, bg: Color) {
    CONSOLE_FG.store(fg.into(), Ordering::SeqCst);
    CONSOLE_BG.store(bg.into(), Ordering::SeqCst);
}

/// Draw a cursor at current position
pub fn console_draw_cursor() {
    if !console_is_ready() {
        return;
    }

    let cx = CONSOLE_CURSOR_X.load(Ordering::SeqCst);
    let cy = CONSOLE_CURSOR_Y.load(Ordering::SeqCst);
    let px = (cx as u32) * FONT_WIDTH;
    let py = (cy as u32) * FONT_HEIGHT;

    let fg: Color = CONSOLE_FG.load(Ordering::Relaxed).into();

    // Draw underscore cursor
    unsafe {
        for x in px..px + FONT_WIDTH {
            put_pixel(x, py + FONT_HEIGHT - 2, fg);
            put_pixel(x, py + FONT_HEIGHT - 1, fg);
        }
    }
}

/// Print formatted output to both serial and graphical console
#[macro_export]
macro_rules! gprint {
    ($($arg:tt)*) => {{
        use core::fmt::Write;
        let mut s = alloc::string::String::new();
        write!(s, $($arg)*).ok();
        crate::framebuffer::console_write_str(&s);
        crate::serial_write_str(&s);
    }};
}

/// Print formatted output with newline
#[macro_export]
macro_rules! gprintln {
    () => { $crate::gprint!("\n") };
    ($($arg:tt)*) => {{
        $crate::gprint!($($arg)*);
        $crate::gprint!("\n");
    }};
}
